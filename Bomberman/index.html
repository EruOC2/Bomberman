<!DOCTYPE html>
<html>

<head>
    <style>
        canvas {
            background-color: white;
        }

        body {
            background-color: black;
        }
    </style>
</head>

<body>

    <center>
        <canvas width="950" height="650" id="myCanvas"></canvas>
    </center>

    <script>
        var canvas = document.getElementById('myCanvas');
        var ctx = canvas.getContext('2d');
        var dir = 0, speed = 2;
        let pause = false;
        let bombLimit = 2; // Límite de bombas
        let bombs = [];
        let explosionSquares = []; // Cuadrados en el área de explosión

        class Cuadrado {
            constructor(x, y, w, h, c) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.c = c;
                this.startTime = Date.now();
            }

            paint(ctx) {
                ctx.fillStyle = this.c;
                ctx.fillRect(this.x, this.y, this.w, this.h);
            }

            seTocan(otro) {
                return this.x < otro.x + otro.w &&
                    this.x + this.w > otro.x &&
                    this.y < otro.y + otro.h &&
                    this.y + this.h > otro.y;
            }
        }

        class Player {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            update() {
                let prevX = this.x;
                let prevY = this.y;

                switch (dir) {
                    case 1:
                        this.y -= speed;
                        if (this.y < 0) {
                            this.y = canvas.height;
                        }
                        break;
                    case 2:
                        this.y += speed;
                        if (this.y > canvas.height) {
                            this.y = -this.height;
                        }
                        break;
                    case 3:
                        this.x += speed;
                        if (this.x > canvas.width) {
                            this.x = -this.width;
                        }
                        break;
                    case 4:
                        this.x -= speed;
                        if (this.x < -this.width) {
                            this.x = canvas.width;
                        }
                        break;
                }

                for (var i = 0; i < walls.length; i++) {
                    if (this.seToca(walls[i])) {
                        this.x = prevX;
                        this.y = prevY;
                        break;
                    }
                }
            }

            seToca(wall) {
                return this.x < wall.x + wall.w &&
                    this.x + this.width > wall.x &&
                    this.y < wall.y + wall.h &&
                    this.y + this.height > wall.y;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class Bomba {
            constructor(x, y, w, h, color, fuseTime, explosionRadius) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.color = color;
                this.active = false; // Bomba no activa al inicio
                this.fuseTime = fuseTime; // Tiempo en milisegundos antes de la explosión
                this.startTime = 0; // Inicializamos startTime en 0
                this.explosionRadius = explosionRadius; // Radio del área de explosión
            }

            draw(ctx) {
                if (this.active) {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                }
            }

            arm() {
                // Armamos la bomba y establecemos el startTime
                this.active = true;
                this.startTime = Date.now();
            }

            explode() {
                // Verificar si la bomba está activa y ha pasado el tiempo de mecha
                const tiempoActual = Date.now();
                if (this.active && tiempoActual - this.startTime >= this.fuseTime) {
                    // La bomba ha explotado (ha alcanzado el tiempo de mecha)
                    this.active = false;

                    // Detectar objetos en el área de explosión y aplicar efectos
                    for (let i = 0; i < walls.length; i++) {
                        const wall = walls[i];
                        const centerX = this.x + this.w / 2;
                        const centerY = this.y + this.h / 2;
                        const distance = Math.sqrt(Math.pow(centerX - (wall.x + wall.w / 2), 2) +
                            Math.pow(centerY - (wall.y + wall.h / 2), 2));

                        // Verificar si el objeto está dentro del radio de explosión y no es una pared
                        if (distance <= this.explosionRadius) {
                            if (wall instanceof BreakableCuadrado && !wall.isBroken) {
                                wall.break();
                            }
                        }
                    }

                    // Generar cuadrados en el área de explosión
                    generateExplosionSquares(this.x, this.y, this.explosionRadius);
                }
            }
        }

        class BreakableCuadrado extends Cuadrado {
            constructor(x, y, w, h, c) {
                super(x, y, w, h, c);
                this.isBroken = false;
            }

            break() {
                this.isBroken = true;
                // Eliminar cuadro roto de la lista de paredes
                const index = walls.indexOf(this);
                if (index !== -1) {
                    walls.splice(index, 1);
                }
            }

            paint(ctx) {
                if (!this.isBroken) {
                    ctx.fillStyle = this.c;
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                }
            }
        }

        function generateExplosionSquares(x, y, radius) {
            // Genera cuadrados en el área de explosión
            for (let i = x - radius; i <= x + radius; i += 20) {
                for (let j = y - radius; j <= y + radius; j += 20) {
                    explosionSquares.push(new Cuadrado(i, j, 20, 20, "orange"));
                }
            }
        }

        const player = new Player(0, 0, 40, 40, "black");
        let walls = [];

        // Limites
        walls.push(new Cuadrado(-10, -10, 1000, 10, "gray"))
        walls.push(new Cuadrado(950, -10, 30, 700, "gray"))
        walls.push(new Cuadrado(-10, -10, 10, 700, "gray"))
        walls.push(new Cuadrado(0, 650, 1000, 10, "gray"))

        // Mapa primera fila de muros
        walls.push(new Cuadrado(50, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(150, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(250, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(350, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(450, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(550, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(650, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(750, 50, 50, 50, "gray"))
        walls.push(new Cuadrado(850, 50, 50, 50, "gray"))

        // Segunda fila
        walls.push(new Cuadrado(50, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(150, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(250, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(350, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(450, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(550, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(650, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(750, 150, 50, 50, "gray"))
        walls.push(new Cuadrado(850, 150, 50, 50, "gray"))

        // Tercera fila
        walls.push(new Cuadrado(50, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(150, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(250, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(350, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(450, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(550, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(650, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(750, 250, 50, 50, "gray"))
        walls.push(new Cuadrado(850, 250, 50, 50, "gray"))

        // Cuarta fila
        walls.push(new Cuadrado(50, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(150, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(250, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(350, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(450, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(550, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(650, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(750, 350, 50, 50, "gray"))
        walls.push(new Cuadrado(850, 350, 50, 50, "gray"))

        // Quinta fila
        walls.push(new Cuadrado(50, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(150, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(250, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(350, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(450, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(550, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(650, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(750, 450, 50, 50, "gray"))
        walls.push(new Cuadrado(850, 450, 50, 50, "gray"))

        // Sexta fila
        walls.push(new Cuadrado(50, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(150, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(250, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(350, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(450, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(550, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(650, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(750, 550, 50, 50, "gray"))
        walls.push(new Cuadrado(850, 550, 50, 50, "gray"))

        const breakableWall = new BreakableCuadrado(100, 100, 50, 50, "blue");
        walls.push(breakableWall);

        window.requestAnimationFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 17);
                };
        }());

        
        document.addEventListener("keydown", (e) => {
            if (!pause) {
                switch (e.keyCode) {
                    case 87:
                        dir = 1;
                        break;
                    case 83:
                        dir = 2;
                        break;
                    case 68:
                        dir = 3;
                        break;
                    case 65:
                        dir = 4;
                        break;
                    case 69: // Tecla "E" para crear una bomba
                        if (bombs.length < bombLimit) {
                            const newBomba = new Bomba(player.x, player.y, 40, 40, "red", 1000, 50); // Bomba con 1000 milisegundos de mecha (1 segundo) y radio de explosión de 50
                            bombs.push(newBomba);
                            newBomba.arm(); // Armamos la bomba con un retardo
                        }
                        break;
                }
            }
        });

        document.addEventListener("keyup", (e) => {
            dir = 0;
        });

        function update() {
            if (!pause) {
                player.update();

                // Verificar colisión del jugador con explosiones
                for (let i = 0; i < explosionSquares.length; i++) {
                    if (player.seToca(explosionSquares[i])) {
                        pause = true;
                        break;
                    }
                }
            }
            updateBombs();
            updateExplosionSquares();
            paint();
            window.requestAnimationFrame(update);
        }

        function updateExplosionSquares() {
            for (let i = 0; i < explosionSquares.length; i++) {
                const maxLifetime = 1000;
                const currentTime = Date.now();
                const lifetime = currentTime - explosionSquares[i].startTime;

                if (lifetime >= maxLifetime) {
                    explosionSquares.splice(i, 1);
                    i--;
                }
            }
        }

        function updateBombs() {
            for (let i = 0; i < bombs.length; i++) {
                bombs[i].explode();
                if (!bombs[i].active) {
                    bombs.splice(i, 1);
                    i--;
                }
            }
        }

        function paint() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < bombs.length; i++) {
                bombs[i].draw(ctx);
            }

            for (let i = 0; i < explosionSquares.length; i++) {
                explosionSquares[i].paint(ctx);
            }

            player.draw();

            for (var i = 0; i < walls.length; i++) {
                walls[i].paint(ctx);
            }

            if (pause) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.font = "40px Georgia";
                ctx.fillStyle = "white";
                ctx.fillText("Game Over", canvas.width / 2 - 70, canvas.height / 2);
            }
        }

        update();

    </script>
</body>

</html>


